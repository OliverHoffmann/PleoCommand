/* $Id$ */

/**
 * @file
 * Script System interface
 *
 * The Script System is used to execute scripts in the various
 * VMs, set VM options, etc.
 *
 * Copyright (c) 2007,2008 Ugobe, Inc.
 */
 
#if defined _script_included
  #endinput
#endif

#define _script_included

#if TARGET == TARGET_PLEO
	// for the compare type
	#include "pleo/properties.inc"
#endif


/**
 * @enum vm_name
 * enumeration of the various VMs in the firmware
 */
enum vm_name {
    vm_none,		/** error or undefined value */
    vm_sensor,		/** Sensor VM, where the sensors(.amx) script is executed */
    vm_main,		/** Main VM, where the main(.amx) is executed */
    vm_aux,			/** Aux or Behavior VM, where behaviors or aux. scripts are executed */
    vm_user			/** User VM, where init(.amx) or monitor initiated scripts are executed */
};


/**
 * @brief execute a script in the aux. VM by name
 * @param name of script to execute
 * @return none
 * @note this function only works with the vm_aux curretly
 */
native vm_exec(const string[], vm_name:vm = vm_aux);

stock exec(const string[], vm_name:vm = vm_aux)
    { return vm_exec(string, vm); }


/**
 * @brief execute a script in the Aux VM by ID
 * @param ID of the script to execute. generated by the build tool. See scripts.inc
 * @return none
 */
native vm_exec_id(script_name:script, vm_name:vm = vm_aux);

stock exec_id(script_name:script, vm_name:vm = vm_aux)
    { return vm_exec_id(script, vm); }


/**
 * @brief execute a script in the sensors VM by file name
 * @param ID of the script to execute. generated by the build tool
 * @return none
 */
stock sensor_exec(const string[])
    { return vm_exec(string, vm_sensor); }


/**
 * @brief execute a script in the sensors VM by ID
 * @param ID of the script to execute. generated by the build tool
 * @return none
 */
stock sensor_exec_id(script_name:script)
    { return vm_exec_id(script, vm_sensor); }


/**
 * @brief create a new Wait object
 * @return new Wait: object if successful. 0 if failed
 */
native Wait: wait_new();

/**
 * @brief add a property value to a wait object 
 * @param wait object gotten from wait_new
 * @param property name to add
 * @param property value to match
 * @param comparison operator to use to match property value
 * @return whether the property could be added or not
 */
native bool: wait_add_property(Wait:wait, property_name:property, value, compare_name:compare);

// TODO: add:
//	wait_add_time, to wait X milliseconds
//  wait_add_sensor, to wait for a specific sensor trigger or value

/**
 * @brief perform the actual wait. will not return from this call until all
 * @param wait object returned from wait_new function
 * @param which vm should wait on this object. defaults to aux VM
 * @return none
 */
native void: vm_wait(Wait:wait, vm_name:vm = vm_aux);


/**
 * @brief give up time back to the native code
 * @return none
 * @note this same functionality is built into the language
 * with the sleep operator, and it is less overhead. Simply
 * replace yield(); with sleep;
 */
native void: yield();


/**
 * @brief forward declaration for the script init function
 * @return none
 */
forward public init();


/**
 * @brief forward declaration for the script main function
 * @return none
 */
forward public main();


/**
 * @brief forward declaration for the script close function
 * @return none
 */
forward public close();
